---
title: "Effective Java - Chapter 9"
last_modified_at: 2021-04-15 T12:19:00-05:00
toc: true
toc_sticky: true
header:
  teaser: /images/effective_Java.png
categories: 
  - Effective Java
tags:
---

> Effective Java

[Effective Java 3/E] 9장 일반적인 프로그래밍 원칙
=============
이번 장에서는 지역변수, 제어구조, 라이브러리, 데이터 타입 등 다양한 요소들에 대하여 다루어 보았다.  
그리고 최적화와 명명 규칙으로 마무리하였다.  

## Item 57 - 지역변수의 범위를 최소화하라
**지역변수의 유효 범위를 최소로 줄이면 코드 가독성과 유지보수성이 높아지고 오류 가능성은 낮아진다.**
1. 지역변수는 가장 처음 쓰일때 선언하자.  
지역변수의 범위를 줄이는 가장 강력한 기법이며, 쓰기 전 미리 선언해두면 가독성을 줄이고 실수를 유발할 수 있다.  
2. 선언과 동시에 초기화 하자  
초기화에 필요한 정보가 충분하지 않다면, 선언을 미뤄야한다.  
3. 반복 변수의 값을 반복 이후에도 쓸것이 아니라면, while문 보다 for문을 쓰자  
* while 문을 사용하면 반복문 밖으로 불필요한 변수가 선언된다.  
* for문을 사용하면 변수의 범위가 몸체 사이의 괄호 안으로 제한된다.  
* while문보다 잛아서 가독성이 좋으며, 실수로 인한 오류를 줄여준다.
4. 메서드를 작게 유지하고 한 가지 기능에만 집중하자
여러 가지 기능을 처리하게 되면 다른 기능을 수행하는 코드에서 접근할 가능성이 있다.  
메서드를 기능별로 나누면 간단해진다.

> 지역변수의 범위를 최소화해야 잠재적인 오류를 줄일 수 있다.

## Item 58 - 전통적인 for 문보다는 for-each 문을 사용하라
배열과 컬렉션의 요소를 탐색할 때 보통 `for` 문을 사용했다. 특히 반복자(iterator)나 인덱스 탐색을 위한 루프 변수는 실제로 필요한 원소를 얻기 위한 코드일 뿐이다. 따라서 불필요하며 오히려 잘못 사용한 경우 오류가 발생할 가능성이 높다.  

따라서, **향상된 for문(for-each)**를 사용하자.  
반복자와 인덱스 변수를 사용하지 않아 코드가 깔끔해지고 오류가 날 일도 없다.  

더욱이 컬렉션을 중첩해 순회해야 한다면, for-each문의 이점이 더 커진다.  

```java
// 2중 for each
for (Suit suit : suits) {
  for (Rank rank : ranks) {
    deck.add(new Card(suit, rank));
  }
}
```

위의 경우, 알아서 rank가 한번 전체 순회를 한 다음에 suit가 다음 순회를 한다.  

### for-each를 사용할 수 없는 상황
* 파괴 / 변형
컬렉션을 순회하면서 선택된 엘리먼트를 제거하거나 변경 한다면 아래와 같이 반복자(iterator)를 명시적으로 사용해야만 한다.  
for-each는 read only이다.  
* 병렬 순회: Parallel iteration  

> for-each 문은 명료하고 유연하며 버그를 예방해주며 성능 저하도 없다.

## Item 59 - 라이브러리를 익히고 사용하라
원하는 기능을 직접 구현하는 것보다 표준 라이브러리를 사용하는 것은 다양한 이점이 있다.   
* 그 코드를 작성한 전문가의 지식과 경험을 활용할 수 있다.  
* 핵심적인 일과 관련없는 시간 소비가 줄어든다.  
* 따로 노력하지 않아도 성능이 지속해서 개선된다.  
* 기능이 점점 많아진다. 요구, 논의되는 기능은 대부분 다음 릴리즈에 기능이 추가된다.  
자바는 메이저 릴리스마다 새로운 기능을 설명하는 웹페이지를 공시하여 읽어보자.  
* 많은 사람들에게 익숙한 코드가 되기 때문에 읽기 좋고, 유지보수하기 좋고, 재활용하기 좋다.  

라이브러리는 매우 방대하기 때문에 최소한 `java.lang`, `java.util`, `java.io`은 익숙해지자.   

> 원하는 기능이 있으면 표준 라이브러리를 찾아보자.   
> 직접 작성한 것보다 품질이 좋고, 개선될 가능성이 크다.    

## Item 60 - 정확한 답이 필요하다면 float와 double은 피하라
`float`와 `double`은 넓은 범위의 수를 빠르고 정밀한 **‘근사치’**로 계산하도록 설계되었다.  
따라서 0.1 또는 10의 음의 거듭 제곱 등을 표현할 수 없기 때문에 금융 관련 계산에는 적합하지 않다.

```java
System.out.println(1.03 - 0.42);
// 예상: 0.61
// 결과: 0.6100000000000001
```

정확한 계산이 필요할 경우, `BigDecimal`, `int` 또는 `long`을 사용하자.  
```java
BigDecimal a = new BigDecimal("1.03");
BigDecimal b = new BigDecimal("0.42");

System.out.println(a.subtract(b));
// 결과: 0.61
```

하지만 `BigDecimal에는` 기본 타입보다 사용하기 불편하고 성능적으로 훨씬 느리다.  
이럴때 `int` 또는 `long` 타입을 사용해야 하는데, 값의 크기가 제한되고 소수점을 직접 관리해야 하는 점이 있다.  

성능 저하에 신경쓰지 않으면 `BigDecimal`를 사용하자.  
9자리 십진수로 표현할 수 있다면 `int`, 18자리 십진수로 표현할 수 있다면 `long`, 18자리가 넘어가면 `BigDecimal`을 사용하면 된다.

> 정확한 계산이 필요할 때는 float와 double은 피하라.

## Item 61 - 박싱된 기본 타입보다는 기본 타입을 사용하라

## 출처
Joshua Bloch. Effective Java 3/E. n.p.: 인사이트, 2018년 11월 1일.  

## Reference

<!-- ★
<img src="/images/Tech/EJ/문제번호.PNG" width="40%" height="40%">  

-->