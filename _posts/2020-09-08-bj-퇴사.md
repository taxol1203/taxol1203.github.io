---
title: "백준 14501번 - 퇴사"
date: 2020-09-08 15:10:00 -0400
categories: 
  - codingTest
tags:
  - DP
  - Burte Force
  - Baek Joon
---

> C++ 

14501번 - 퇴사
=============
 
[문제 출처](https://www.acmicpc.net/problem/14501)
## 문제
상담을 적절히 했을 때, 백준이가 얻을 수 있는 최대 수익을 구하는 프로그램을 작성하시오.

## 접근 방법 및 구현
동적 계획법으로 풀어야 하는 문제이다.
동적 계획법 문제는 정말 다양한 점화식으로 접근 할 수 있는데, 제가 푼 방법을 소개해 드리겠습니다. 

이 코드는 세 부분으로 나누어 지는데,
1. 현재 상담의 금액 + 현재 상담일에서 벌어 놓은 돈 : P[i] + dp[i]
2. 현재 상담 만큼의 기간 T[i]이 걸린 이후에 벌어 놓은 돈 : dp[i + T[i]] 
3. 현재 벌어 놓은 돈과 전날 벌어 놓은 돈을 비교 : max(dp[i], dp[i-1])
이다.

말로는 설명하기 어려우니, 표를 통해서 설명해드리겠습니다.

|    | 1  | 2  | 3  | 4  | 5  | 6  | 7  | 8  | 9  | 10 |
|----|----|----|----|----|----|----|----|----|----|----|
| T  | 5  | 4  | 3  | 2  | 1  | 1  | 2  | 3  | 4  | 5  |
| P  | 50 | 40 | 30 | 20 | 10 | 10 | 20 | 30 | 40 | 50 |
| DP | 0  | 0  | 0  | 0  | 0  | 0  | 0  | 0  | 0  | 0  |



## 코드 
```c++
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

#define maxN 17
int n;
int dp[maxN];
int T[maxN];	//상담을 완료하는데 걸리는 기간
int P[maxN];	//해당 상담을 끝냈을 때, 받을 수 있는 금액

int main(int argc, char* argv[]) {
	
	cin >> n;

	for (int i = 1; i <= n; i++) {
		cin >> T[i] >> P[i];
	}
	//첫번째 상담 부터 시작한다.
	for (int i = 1; i <= n; i++) {
		//만약 그 날 상담을 하지 않을 때를 대비하여, 전날에 결과 dp를 당일에 복사한다.
		dp[i] = max(dp[i], dp[i - 1]);
		//현재 상담을 완료한 시점 < dp값이 현재 상담 금액 + 현재까지 번 돈 일시 
		if (dp[i + T[i]] < P[i] + dp[i]) {
			dp[i + T[i]] = P[i] + dp[i];
		}
	}
	//가장 많이 돈을 번 상담 금액을 출력
	cout << *max_element(dp + 2, dp + n + 2);
	return 0;
}
```

## 후기 및 개선할 점

후기:

처음에는 BFS로 풀려고 알고리즘을 짜보다, 안전항 영역의 수를 찾을 수 없다는 것을 판단하여 DFS인 이전에 풀었떤 알고리즘을 가져와 풀었다.
모든 좌표의 값이 1인 케이스를 판단하지 못하여 `틀렸습니다`가 나와 고민을 조금 하였다.