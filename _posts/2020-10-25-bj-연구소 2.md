---
title: "백준 17141 - 유레카 이론"
date: "`r format(Sys.Date())`"
categories: 
  - codingTest
tags:
  - DFS
  - Back Tracking
  - Brute Force
  - Baek Joon
---

> C++ 

17141번 - 유레카 이론
=============
 
## 문제
연구소의 상태가 주어졌을 때, 모든 빈 칸에 바이러스를 퍼뜨리는 최소 시간을 구해보자.
[문제 출처](https://www.acmicpc.net/problem/17141)

## 접근 방법 
1. 모든 바이러스의 좌표를 저장 한다. 
2. DFS를 이용하여 m개의 바이러스를 뽑는다.
3. 뽑은 바이러스의 좌표를 BFS를 통해 퍼트린다.
4. 이 그래프에서 바이러스가 퍼진 시간의 최댓값을 계산하고, 이 최대값이 전체 퍼진 시간보다 작으면 갱신한다.
5. 2번으로 돌아와 반복한다.


## 구현 


## 코드 - Back Tracking
```c++
#include <iostream>
#include <vector>
#include <queue>
#include <algorithm>

using namespace std;

#define MAX 999999999;
int n, m, v, result = MAX;
int graph[50][50], sel[10], time[50][50];
int visited[50][50], saved[50][50];
bool success = false;
vector<pair<int, int>> virusPossi;

void DFS(int lv, int idx);
void BFS();
void print();
void getResult();
void init();

int main() {
    ios::sync_with_stdio(false);
    cin.tie(NULL);
    cin >> n >> m;
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            cin >> graph[i][j];
            if(graph[i][j] == 2)
                virusPossi.push_back(make_pair(i, j));
            else if (graph[i][j] == 1) {
                visited[i][j] = true;
                saved[i][j] = true;
            }
        }
    }
    v = virusPossi.size();
    DFS(0, 0);
    if (success)
        cout << result;
    else
        cout << -1;
}

void DFS(int lv, int idx) {
    if (lv == m) {
        BFS();
        getResult();
        init();
        return;
    }
    for (int i = idx; i < v; i++) {
        sel[lv] = i;
        DFS(lv + 1, i + 1);
    }
}

void print() {                      //m개의 바이러스를 제대로 뽑았는지 확인하기 위한 함수. 결과에는 영향이 없다.
    for (int i = 0; i < m; i++) {
        cout << sel[i] << " ";
    }
    cout << "\n";
}

int goy[4] = { -1, 1, 0 ,0 };
int gox[4] = { 0, 0, -1, 1 };
void BFS() {
    queue<pair<int, int>> virus;
    int y, x, cury, curx;
    for (int i = 0; i < m; i++) {
        virus.push(virusPossi.at(sel[i]));
        y = virusPossi.at(sel[i]).first;
        x = virusPossi.at(sel[i]).second;
        visited[y][x] = true;
    }
    int t = 1, vc, cnt = 0;
    while (!virus.empty()) {
        vc = virus.size();
        while (vc--) {
            y = virus.front().first;
            x = virus.front().second;
            virus.pop();
            for (int i = 0; i < 4; i++) {
                cury = y + goy[i];
                curx = x + gox[i];
                if (-1 < cury && cury < n && -1 < curx && curx < n && !visited[cury][curx]) {
                    virus.push(make_pair(cury, curx));
                    visited[cury][curx] = true;
                    time[cury][curx] = t;
                }
            }
        }
        t++;
    }
}

void getResult() {
    int maxNum = 0;
    bool failed = false;
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            if (time[i][j] > 0) {
                maxNum = max(maxNum, time[i][j]);
            }
            else if (visited[i][j] == 0)
                failed = true;
        }
    }
    if (!failed) {                  //모든 빈 칸에 바이러스를 퍼뜨렸다.
        result = min(maxNum, result);
        success = true;
    }
}
void init() {
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            visited[i][j] = saved[i][j];
            time[i][j] = 0;
        }
    }
}
```

## 후기 및 개선할 점
문제 조건에 강조한, **단, 3개의 삼각수가 모두 달라야 할 필요는 없다**를 읽지 못하여 계속하여 틀렸다.  
처음에 백 트래킹으로 풀었다가 틀려 조합의 방식으로도 풀었는데, 채점의 같은 지점에서 `틀렸습니다`가 나와 분명 문제 조건에서 틀렸다고 생각하여 확인해보니  
혹시나가 역시나라고, 중복을 배제하여 풀었는데 중복 허용이라 적혀있어 허탈하였다.  
그래도 2가지의 방식으로, 또한 정답을 보지 않고 나의 힘으로 풀었다는 것에 의의를 둔다.