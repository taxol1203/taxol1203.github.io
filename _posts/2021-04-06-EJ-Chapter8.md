---
title: "Effective Java - Chapter 8"
last_modified_at: 2021-04-06 T12:19:00-05:00
toc: true
toc_sticky: true
header:
  teaser: /images/effective_Java.png
categories: 
  - Effective Java
tags:
---

> Effective Java

[Effective Java 3/E] 8장 메서드
=============
이번 장에서는  
1. 매개변수와 반환값 처리    
2. 메서드 시그니처 설계  
3. 문서화  
에 대해 다루어 본다.  
## Item 49 - 매개변수가 유효한지 검사하라  
메서드의 입력 매개변수가 특정 조건을 만족해야 할 시에, 검사를 가능한 빨리 하여 오류를 사전에 잡아야한다.  
매개 변수 검사에 실패하면 실패 원자성을 어기는 결과를 낳게 된다.  
따라서, 매개변수 제약을 문서화 하고, 이를 어기면 던지는 예외도 문서화를 해야한다.  

### 매개변수가 유효한지 확인하는 방법
1. 자바의 null 검사 기능 사용  
```java
public void someMethod(Integer val) {
    Integer integer = Objects.requireNonNull(val, "매개변수가 null!");
    System.out.println(integer);
}
```

2. Objects에 범위 검사 기능
리스트와 배열 전용으로 설계된 범위 검사 가능이다.  
`checkFromIndexSize`, `checkFromToIndex`, `checkIndex`을 사용한다.  
```java
List<String> list = List.of("a", "b", "c");
// Exception in thread "main" java.lang.IndexOutOfBoundsException: 
//      Index 4 out of bounds for length 3
Objects.checkIndex(4, list.size());
```

3. 단언문(`assert`) 사용
private로 공개되지 않은 메서드이면 `assert`를 사용하여 유효성을 검사한다.   
넘어온 매개변수가 조건식을 참으로 만들지 않으면 `AssertionError`를 던진다.  
```java
private void someMethod(int arr[], int length) {
    assert arr != null;
    assert length >= 0 && arr.length == length;

    // do something
}
```

### 매개변수 유효성 검사를 하지 않는 경우
유효성을 검사하는 비용이 지나치게 큰 경우 또는 계산 과정에서 암묵적으로 유효성 검사가 진행될 때는 유효성 검사를 건너 뛸 수도 있다.  
예를 들어 `Collections.sort(List)`처럼 리스트를 정렬할 때는 정렬 과정에서 모든 객체가 상호 비교된다.  
만일 비교할 수 없는 타입의 객체가 있으면 `ClassCastException`이 발생할 것이기 때문에 비교하기에 앞서 모든 원소를 검증하는 것은 불필요한 과정이 된다.  

## Item 50 - 적시에 방어적 복사본을 만들라
클래스가 클라이언트로부터 받거나 클라이언트에게 반환하는 구성 요소가 가변적이라면 그 요소는 반드시 방어적으로 복사해야 한다.

### 생성자로 받은 가변 매개변수 각각을 방어적 복사 해야한다.
```java
class Period {
  private final Date start;
  private final Date end;

  public Period(Date start, Date end) {
      if(start.compareTo(end) > 0) {
          throw new IllegalArgumentException(start + " after " + end);
      }
      this.start = start;
      this.end = end;
  }
  public Date start() { return start; }
  public Date end() { return end; }
  // ... 생략
}
```

```java
Date start = new Date();
Date end = new Date();
Period period = new Period(start, end);
end().setMonth(3);    // period의 내부를 수정했다.
```
Period 생성자의 매개변수로 주어진 `end` Date 객체를 외부에서 변경하면, Period 내부의 Date 객체도 같이 변ㅁ경 된다. -> 불변성을 해치는 상황!  

```java
// 방어적 복사를 적용한 생성자
public Period(Date start, Date end) {
  this.start = new Date(start.getTime());
  this.end = new Date(end.getTime());

  // 유효성 검사 전에 복사해야 한다. 
  if(start.compareTo(end) > 0) {
      throw new IllegalArgumentException(start + " after " + end);
  }
}
```
new 키워드를 통하여 새로운 `Date`객체를 만들어 이를 Period의 인스턴스로 생성한다.  
clone을 사용하지 않는 이유는 `Date`의 재정의한 clone 메서드가 외부에서 악용을 위해 정의하였을 수도 있다.  

### 접근자로 주어지는 인스턴스를 방어적 복사하여 전달한다.
```java
Date start = new Date();
Date end = new Date();
Period period = new Period(start, end);
// period의 인스턴스를 수정하여 불편식을 해치고 있다. 
period.end().setMonth(3);
```
Period의 인스턴스를 반환하는 `end()` getter 메서드를 통하여 인스턴스에 접근하였다.  
근데 클라이언트가 `setMonth(3)`를 통하여 내부를 수정하는 결과를 초래하였다.  

따라서, getter로 객체의 인스턴스를 전달 할 때에도 방어적 복사를 이용하여 수정을 하지 못하게 막는다.  
```java
public Date start() { 
  return new Date(start.getTime()); // 새로운 Date 객체를 만들어 반환
}
public Date end() { 
  return new Date(end.getTime());
}
```
접근자 메서드에서는 방어적 복사를 사용해도 된다.  

### 방어적 복사를 하지 않아도 될 때
방어적 복사 비용이 너무 크거나, 클라이언트가 컴포넌트 내부를 수정하지 않는다고 신뢰할 경우에는 생략해도 된다.  
또한, 구성요소를 수정 하였을 때 영향이 그 클라이언트에만 국한되어있다면 생략해도 된다.  
대신 문서화를 하여 명시를 해야하는 것을 잊지말자.  

## Item 51 - 매서드 시그니처를 신중히 설계하라
이번 장은 다양한 설계 요령들을 정리 하였다.

### 메서드 이름을 신중히 짓자
항상 표준 명명 규칙을 따르자.  
같은 패키지에 속한 다른 이름과 일관되게 짓자.  
널리 쓰이는 이름이나 자바 라이브러리의 API 가이드를 참고하여 작명하자.  

### 편의 메서드를 너무 많이 만들지 말자
클래스 혹은 인터페이스의 메서드가 많아지면 유지보수 하기에 어렵다.  
아주 자주 쓰이는 것들만 별도의 약칭을 두어 메서드로 사용하자.  

### 매개변수 목록은 짧게 유지하자
매개변수는 4개 이하가 좋다.  
매개변수가 많아지면, 사용자들이 API를 사용하는데 혼돈이 오며 같은 타입의 매개변수가 여러개가 연달아 나오는 등의 경우 잘못 된 인자로 전달하여 의도와 다르게 동작할 수가 있다.  
매개변수를 줄이는 방법은 다음과 같이 3가지가 있다.  

1. 여러 메서드로 나누어 본다.
독립된 기능을 하는 메서드로 구분을 하자.  
```java
List<String> list = Lists.of("a", "b", "c", "d");
// 전체가 아닌 지정된 범위의 부분 리스트에서 인덱스를 찾는 경우
List<String> newList = list.subList(1, 3);  // 부분 리스트 추룰
int index = newList.indexOf("b");           // 추출한 리스트에서 인덱스 찾기
```

2. 도우미(Helper) 클래스를 만들자  
```java
// 기존 메서드
public void someMethod(String a, String b, String c, String d) {
  // do something
}

// Helper 클래스 적용
class HelperClass {
  String a;
  String b;
  String c;
  String d;
}

public void someMethod(HelperClass someHelper) {
  // do something
}
```

3. 빌더 패턴을 이용하자


### 매개변수의 타입으로는 클래스보다는 인터페이스가 더 낫다


## Item 52 - 다중정의는 신중히 사용하라

## Item 53 - 가변인수는 신중히 사용하라
> 가변 인수란?
> 명시한 타입을 0개 이상 받을 수 있는 인수
> 가변 인수 메서드를 호출하면, 인수의 개수와 길이가 같은 배열을 만들어 건네준다.

인수가 1개 이상이어야 할 때는 아래와 같이 가변인수 앞에 필수 매개변수를 받도록한다.  
```java
static int min(int firstArg, int... remainingArgs) {
  int min = firstArg;
  for (int arg : remainingArgs) {
      if (arg < min) {
          min = arg;
      }
  }
  return min;
}
```

가변인수 메서드가 호출될 때마다 배열을 새로 할당하고 초기화한다는 이유로, 성능에 해가 될 수 있기 때문에, 성능이 걱정된다면 아래와 같은 패턴으로 해결한다.  

```java
public void foo() {}
public void foo(int arg1) {}
public void foo(int arg1, arg2) {}
public void foo(int arg1, arg2, arg3) {}  // 메서드 호출의 95% 이상이 3개 이하의 인수를 사용
public void foo(int arg1, arg2, arg3, int... restArg) {}
```

## Item 54 - Null이 아닌, 빈 컬렉션이나 배열을 반환하라
어떤 클래스의 List 인스턴스를 반환하는 getter가 있다고 하자.  
```java
private final List<Cheese> cheesesInStock = ...;

public List<Cheese> getCheeses() {
  return cheesesInStock.isEmpty() ? null : new ArrayList<>(cheesesInStock);
}
```
만약 인스턴스가 비어있다면, null을 반환한다.  
이는 위 API를 사용하는 클라이언트에서 NULL을 방어하는 코드를 추가해주어야하는 번거로움이 있다.  

NULL 반환과 빈 컨테이너의 반환의 성능차이는 큰 차이가 없어, 굳이 null을 반환하지 않아도 된다.  

```java
public List<Cheese> getCheeses() {
  // cheesesInStock의 값이 없다면 빈 컨테이너 반환
  return new ArrayList<>(cheesesInStock); 
}
```

빈 컬렉션의 할당이 성능을 저하 시킬수 있다고 판단되면, 매번 같은 **불변 컬렉션** 을 반환하면 된다.  
```java
public List<Cheese> getCheeses() {
  return cheesesInStock.isEmpty() ? Collections.emptyList() : new ArrayList<>(cheesesInStock);
}
```

배열의 경우, null 대신에 길이가 0인 배열을 반환하면 된다.  
성능이 걱정된다면, 길이 0짜리 배열을 미리 선언하고 그 배열을 반환한다.  

```java
// 매번 새로 할당하지 않게 하는 방법
private static final Cheese[] EMPTY_CHEESE_ARRAY = new Cheese[0];

public Cheese[] getCheeses() {
  return cheesesInStock.toArray(EMPTY_CHEESE_ARRAY);
  // 다음과 같이 미리 할당하는 것은 성능을 저하한다.
  // return cheesesInStock.toArray(new Cheese[cheesesInStock.size()]);
}
```
반환하는 배열의 길이가 0이상이면, Cheese[] 배열을 새로 만들어 그 안에 원소를 담고, 원소가 0개면 EMPTY_CHEESE_ARRAY을 반환하게 된다.  

## 출처
Joshua Bloch. Effective Java 3/E. n.p.: 인사이트, 2018년 11월 1일.  

## Reference

<!-- ★
<img src="/images/Tech/EJ/문제번호.PNG" width="40%" height="40%">  

-->