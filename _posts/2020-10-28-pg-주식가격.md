---
title: "2019 카카오 개발자 겨울 인턴십 - 크레인 인형뽑기 게임"
date: 2020-10-16 23:12:00 -0400
categories: 
  - codingTest
tags:
  - Programmers
---

> C++ 

2019 카카오 개발자 겨울 인턴십 - 크레인 인형뽑기 게임
=============
 
## 문제
게임 화면의 격자의 상태가 담긴 2차원 배열 board와 인형을 집기 위해 크레인을 작동시킨 위치가 담긴 배열 moves가 매개변수로 주어질 때, 크레인을 모두 작동시킨 후 터트려져 사라진 인형의 개수를 return 하도록 solution 함수를 완성해주세요.

[문제 출처](https://programmers.co.kr/learn/courses/30/lessons/64061?language=cpp)

## 접근 방법 
먼저 각 크레인의 위치를 하나씩 가져온 뒤, 가져온 크레인 위치에서 위에서 부터 하나씩 내려가며 인형을 찾는다.
인형 발견 시, 바구니에 담는다.
만약 바구니 제일 위의 인형이 현재 뽑은 인형과 같은 인형이면 둘다 제거!

## 구현
2개의 `for`문을 이용하여 문제를 해결한다.
1. 크레인의 위치를 하나씩 가져오는 `for`
2. 현재 위치 위에서 부터 내려오는 `for`
바구니는 `st`라는 vector를 이용해 표현하였다.
현재 바구니의 제일 위에 있는 인형을 가져오기 위해 `vector.back()` 함수를 사용하였다.

## 코드 
```c++

#include <iostream>
#include <vector>
#include <stack>

using namespace std;

vector<int> solution(vector<int> prices) {
    vector<int> answer;
    int price = 0;
    for (int i = 0; i < prices.size(); i++) {
        for (int j = i + 1; j < prices.size(); j++) {
            price++;
            if (prices.at(i) > prices.at(j)) {
                break;
            }
        }
        answer.push_back(price);
        price = 0;
    }
    return answer;
}

vector<int> solution_stack(vector<int> prices) {
    int n = prices.size();
    vector<int> answer(n);
    stack<int> time;
    int price = 0;
    for (int i = 0; i < n; i++) {
        time.push(i);
        while (!time.empty() && prices.at(time.top() > prices.at(i))) {
            int top = time.top();
            time.pop();
            answer.at(top) = i - top;
        }
    }
    while (!time.empty()) {
        int top = time.top();
        time.pop();
        answer[top] = n - top - 1;
    }
    return answer;
}
```

## 후기 및 개선할 점
15분
`vector.back()` 메소드 기억!