---
title: "SWEA 2531 - 회전 초밥"
last_modified_at: 2021-04-15 T22:16:00-05:00
toc: true
toc_sticky: true
header:
  teaser: /images/swea.png
categories: 
  - codingTest
tags:
  - Sliding window
  - SWEA
---

> Java

2531 번 - 회전 초밥
=============
 
## 문제
1. 임의의 한 위치부터 k개 접시를 연속하여 먹는다.   
2. 보너스로 하나의 스시(c)를 제공한다.   

가능한 한 다양한 종류의 초밥을 먹으려고 한다.  

회전 초밥 음식점의 벨트 상태, 메뉴에 있는 초밥의 가짓수, 연속해서 먹는 접시의 개수, 쿠폰 번호가 주어졌을 때, 손님이 먹을 수 있는 초밥 가짓수의 최댓값을 구하는 프로그램을 작성하시오. 

2 ≤ N ≤ 30,000, 2 ≤ d ≤ 3,000, 2 ≤ k ≤ 3,000 (k ≤ N), 1 ≤ c ≤ d

[<img src="/images/swea.png" width="60%" height="60%">](https://swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AV5PpLlKAQ4DFAUq)  

## 접근 방법
스시의 순서대로 0부터 n-1까지 탐색하여, k개의 스시를 매번 탐색해 종류의 세는 방식으로 해결하면, 
O(n^2)의 시간으로 시간초과이다.  

따라서, Sliding window를 통하여 해결하였다.  
처음 인덱스 0에서부터 k개만큼의 스시를 각 스시의 타입을 나타내는 배

## 코드
```java
import java.util.*;
import java.io.*;

public class Main {
	static int n, d, k, c, result;
	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    	StringTokenizer stk = new StringTokenizer(br.readLine());
    	n = stoi(stk.nextToken());
    	d = stoi(stk.nextToken());
    	k = stoi(stk.nextToken());
    	c = stoi(stk.nextToken());
    	
    	
    	int[] sushi = new int[n * 2];
    	for(int i = 0; i < n; i++)
    		sushi[i] = stoi(br.readLine());
    	
    	int[] type = new int[d + 1];
    	
    	for(int i = 0; i < k; i++)
    		sushi[n + i] = sushi[i];
    	
    	int cnt = 0;
    	// 스시 추가
    	for(int i = 0; i < k; i++) {
    		// 만약 처음 넣는 스시이면
    		if(type[sushi[i]] == 0) {
    			cnt++;
    		}
    		type[sushi[i]]++;	// 해당 스시의 개수 증가
    	}
    	
    	// 보너스 스시 추가
    	if(type[c] == 0) {
			cnt++;
		}
		type[c]++;
    	
		result = cnt;
    	
    	for(int i = k; i < n + k - 1; i++) {
    		// 앞 포인터의 스시 제거
    		type[sushi[i - k]]--;		
    		if(type[sushi[i - k]] == 0)		// 더 이상 해당 스시가 없으면
    			cnt--;
    		
    		// 뒤 포인터의 스시 추가
    		if(type[sushi[i]] == 0) {		// 새로 추가된 스시이면
    			cnt++;
    		}
    		type[sushi[i]]++;

    		result = Math.max(result, cnt);
    	}
    	
    	System.out.println(result);
    	br.close();
	}

	
	static int stoi(String str) {
    	return Integer.parseInt(str);
    }
}
```

## 총평
### 후기
L이 1일때 처음 위치도 기록되지 않아, 이를 고려해야겠다는 생각만 하고 실제로 적용하지 않아 처음에는 틀렸다.  
이런 사소한 것이 합격 불합격을 나타내니, 매번 생각 날 때마다 주석으로 달자.  
나중에 분명히 잊는다.  
### 개선할 점
없