---
title: "Effective Java - Item 13"
last_modified_at: 2021-02-26 T22:04:00-05:00
toc: true
toc_sticky: true
header:
  teaser: /images/effective_Java.png
categories: 
  - Effective Java
tags:
---

> Effective Java

Item 13. 재정의는 주의해서 진행하라
=============
## Clonealbe
Cloneable은 어떤 클래스를 복제해도 된다는 사실을 알리기 위해서 만들어진 믹스인 인터페이스(item 20)이다.   
단, clone 메서드가 선언된 곳이 Cloneable이 아닌 Object이며,  
Cloneable의 인터페이스를 구현한 클래스는 Object의 메소드인 clone()을 어떤 식으로 사용할 것인지를 결정할 수 있게 한다.  
즉, Cloneable을 구현한 인스턴스에서 clone() 메소드를 호출하게 되면, 해당 객체를 복사한 객체를 반환하게 된다.  

### Mixin Interface
실제 클래스가 가지고 있는 주된 기능에 특정 타입을 구현함으로써 선택적인 기능을 혼합하게 하는 인터페이스  
```java
public class MyCloneable implements Cloneable{
  private String name;

  public MyCloneable(String name) {
    this.name = name;
  }
  
  @Override
  public MyCloneable clone() throws CloneNotSupportedException {
    return (MyCloneable)super.clone();   // Object의 clone 메서드를 호출한다.
  }
}
```
Object의 clone 메서드를 통하여 새로운 MyCloneable 객체를 반환하게 하였다.  
단, super.clone()은 object를 반환하여 MyCloneable로 type cast를 해주었다. 이는 공변 반환 타입으로 인해 상위 클래스의 메소드가 반환하는 타입(Object)의 하위 타입이라서 가능한 것이다.  
 
## 가변 객체의 Cloneable
위의 예와 같이 모든 필드가 기본 타입이거나 불변 객체를 참조한다면 아무 이슈가 없지만, 만약 리스트와 같은 `가변 객체`가 포함되어 있으면 추가로 수정해주어야 한다.  
```java
public class MyCloneable implements Cloneable{
  private String name;
  private int[] arr;

  public MyCloneable(String name) {
    this.name = name;
    arr = new int[100];
  }
  
  @Override
  public MyCloneable clone() throws CloneNotSupportedException {
    return (MyCloneable)super.clone();   // Object의 clone 메서드를 호출한다.
  }
}
```
위와 같은 int 배열이 추가 된 상황에서 clone으로 새로운 객체를 복사하였다고 하자.  
이의 결과는 반환된 MyCloneable 인스턴스의 String 필드는 올바른 값을 갖겠지만, arr 필드는 원본 MyCloneable 인스턴스와 똑같은 배열을 참조할 것이다.  
즉, 원본이나 복제본 둘 중 하나를 수정하면 다른 하나도 수정되어 불변식을 해친다는 이야기다.  
이를 얕은 복제(Shallow Copy)라고 한다.

clone 메서드는 사실상 생성자와 같은 효과를 낸다. 따라서 가변 객체도 복제될 수 있는 로직을 추가하여 제대로 된 복사를 진행한다.  
```java
public class MyCloneable implements Cloneable{
  private String name;
  private int[] arr;

  public MyCloneable(String name) {
    this.name = name;
    arr = new int[100];
  }
  
  @Override
  public MyCloneable clone() throws CloneNotSupportedException {
    Stack result = (MyCloneable)super.clone();   // Object의 clone 메서드를 호출한다.
    result.arr = arr.clone();   // Deep Copy
    return result;
  }
}
```
<!--
## 좀 더 복잡한 가변 객체의 Cloneable

```java
public class MyCloneable implements Cloneable{
  private String name;
  private InnerClass[] IC = ...;

  private static class InnerClass{
    int val;
    InnerClass(int val){
      
    }
  }
  
  @Override
  public MyCloneable clone() throws CloneNotSupportedException {
    Stack result = (MyCloneable)super.clone();   // Object의 clone 메서드를 호출한다.
    result.arr = arr.clone();   // Deep Copy
    return result;
  }
}
```
-->
## Clonealbe 구현 주의사항
1. clone()을 구현할 때, 재정의될 수 있는 메서드를 호출하지 않아야 한다.  
clone이 하위 클래스에서 재정의한 메서들르 호출하면, 하위 클래스는 자신의 상태를 잃게되어 원본과 복제본의 상태가 달라질 가능성이 크다.  


## 정리
얕은 복사는 객체 내부에 있는 참조 객체가 복제되지 않는 것이고, 깊은 복사는 객체 내부에 있는 참조 객체까지 복제되는 것이다.


## 출처
Joshua Bloch. Effective Java 3/E. n.p.: 인사이트, 2018년 11월 1일.  

## 참고 페이지
<https://icarus8050.tistory.com/70>  
<https://dlsrb6342.github.io/2019/04/30/Effective-Java-3rd-ITEM-12/>